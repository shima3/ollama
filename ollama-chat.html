<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>AI Chat with Ollama</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- highlight.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- MathJax for LaTeX rendering -->
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
      },
      svg: {
        fontCache: 'global'
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    <style>
        :root {
            --primary-color: #4a90e2;
            --background-color: #f4f7f9;
            --container-bg-color: #ffffff;
            --user-message-bg: #dcf8c6;
            --ai-message-bg: #e9e9eb;
            --text-color: #333;
            --border-color: #e0e0e0;
            --error-color: #d9534f;
            --code-bg-color: #282c34;
            --code-header-bg: #3a404a;
            --font-family: 'Helvetica Neue', Arial, sans-serif;
        }
        
        body {
            font-family: var(--font-family);
            background-color: var(--background-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100dvh;
            color: var(--text-color);
        }

        .app-container {
            width: 100%;
            max-width: 800px;
            background-color: var(--container-bg-color);
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: calc(100dvh - 40px);
        }
        
        header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px 20px;
            text-align: center;
            font-size: 1.5em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header h1 { margin: 0; font-size: 1.2em; }
        #settings-toggle { background: none; border: 1px solid white; color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 0.8em; }
        
        #settings-form { border-bottom: 1px solid var(--border-color); }
        #settings-form.hidden { display: none; }
        .settings-content { padding: 20px; }

        .settings-grid { display: grid; grid-template-columns: 1fr; gap: 15px; }
        @media (min-width: 600px) { .settings-grid { grid-template-columns: 1fr 1fr; } }
        .form-group { display: flex; flex-direction: column; }
        .form-group label { margin-bottom: 5px; font-weight: bold; font-size: 0.9em; }
        .form-group input { padding: 10px; border: 1px solid var(--border-color); border-radius: 5px; font-size: 1em; }
        .apply-settings-wrapper { text-align: right; margin-top: 20px; }
        
        #chat-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-height: 0;
        }
        
        #chat-history {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .message-row {
            display: flex;
            align-items: flex-end;
            gap: 8px;
        }

        .message-row.user {
            align-self: flex-end;
            flex-direction: row-reverse;
            max-width: 90%;
        }

        .message-row.ai {
            align-self: flex-start;
            max-width: 100%;
        }

        .message {
            padding: 10px 15px;
            border-radius: 18px;
            display: flex;
            flex-direction: column;
        }

        .message-timestamp {
            font-size: 0.75em;
            color: #888;
            white-space: nowrap;
            padding-bottom: 5px;
            flex-shrink: 0;
        }

        .copy-message-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            opacity: 0.6;
            transition: opacity 0.2s, background-color 0.2s;
        }
        .copy-message-btn:hover {
            opacity: 1;
            background-color: rgba(0,0,0,0.08);
        }
        .copy-message-btn svg {
            width: 16px;
            height: 16px;
            fill: #555;
        }

        .message-content { white-space: normal; word-break: break-word; }
        .message-content img { max-width: 100%; border-radius: 8px; margin-top: 8px; }

        .user-message {
            background-color: var(--user-message-bg);
            border-bottom-right-radius: 4px;
        }
        .ai-message {
            background-color: var(--ai-message-bg);
            border-bottom-left-radius: 4px;
        }
        
        .ai-message .message-content p, .user-message .message-content p { margin-top: 0; margin-bottom: 0.5em; }
        .ai-message .message-content p:last-child, .user-message .message-content p:last-child { margin-bottom: 0; }
        .ai-message .message-content ul, .ai-message .message-content ol,
        .user-message .message-content ul, .user-message .message-content ol { padding-left: 20px; margin-top: 0.5em; margin-bottom: 0.5em; }
        .ai-message .message-content li, .user-message .message-content li { margin-bottom: 0.25em; }
        .ai-message .message-content blockquote, .user-message .message-content blockquote { border-left: 4px solid #ccc; padding-left: 10px; margin-left: 0; color: #666; font-style: italic; }
        .ai-message .message-content a, .user-message .message-content a { color: var(--primary-color); }
        .ai-message .message-content table, .user-message .message-content table { border-collapse: collapse; margin: 1em 0; width: 100%; }
        .ai-message .message-content th, .ai-message .message-content td,
        .user-message .message-content th, .user-message .message-content td { border: 1px solid #ccc; padding: 8px; }
        .ai-message .message-content th, .user-message .message-content th { background-color: #f0f0f0; }

        mjx-container { text-align: left !important; }

        .code-block-wrapper { margin: 1em 0; border-radius: 8px; overflow: hidden; }
        .code-header { display: flex; justify-content: space-between; align-items: center; background-color: var(--code-header-bg); padding: 5px 10px; color: #ccc; font-size: 0.8em; }
        .code-header .language-name { font-weight: bold; }
        .code-header .code-actions button { background: none; border: 1px solid #777; color: #ccc; padding: 3px 8px; border-radius: 4px; cursor: pointer; margin-left: 8px; font-size: 0.9em; }
        .code-header .code-actions button:hover { background-color: #555; }
        pre, code { margin: 0; font-family: 'Courier New', Courier, monospace; }
        
        .code-block-wrapper pre {
            background-color: var(--code-bg-color);
            padding: 15px;
            max-height: 400px;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-y: auto;
        }
        .message-content > p > code, .message-content > ul li code, .message-content > ol li code {
            background-color: rgba(0,0,0,0.08);
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .svg-container { background: #fff; border: 1px solid var(--border-color); border-radius: 8px; padding: 10px; margin: 1em 0; }
        .svg-container svg { max-width: 100%; height: auto; display: block; }

        .message-files-container { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
        .user-message .message-files-container img { max-width: 150px; max-height: 150px; border-radius: 8px; margin-top: 0; }
        .file-display-item { display: inline-flex; align-items: center; gap: 8px; background-color: rgba(0, 0, 0, 0.05); padding: 6px 12px; border-radius: 16px; font-size: 0.9em; }
        .file-display-item svg { width: 16px; height: 16px; fill: #555; flex-shrink: 0; }
        
        .message-content [data-file-id] {
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .message-content [data-file-id]:hover {
            opacity: 0.8;
        }

        .typing-indicator-bubble {
            background-color: var(--ai-message-bg);
            border-radius: 18px;
            border-bottom-left-radius: 4px;
            padding: 12px 18px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .typing-dot {
            width: 8px;
            height: 8px;
            background-color: #8e8e93;
            border-radius: 50%;
            animation: typing-blink 1.4s infinite both;
        }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes typing-blink { 0% { opacity: 0.2; } 20% { opacity: 1; } 100% { opacity: 0.2; } }

        #chat-form { flex-shrink: 0; }
        #chat-form-container { padding: 10px 20px 20px 20px; border-top: 1px solid var(--border-color); }
        #input-wrapper { display: flex; flex-direction: column; border: 1px solid var(--border-color); border-radius: 20px; padding: 5px; }
        #input-wrapper.drag-over { border-color: var(--primary-color); border-style: dashed; }
        #file-preview { display: flex; flex-wrap: wrap; gap: 8px; padding: 0 10px 8px 10px; }
        .file-item { background-color: #f0f0f0; padding: 5px 8px; border-radius: 12px; font-size: 0.8em; display: flex; align-items: center; gap: 5px; }
        .file-item .remove-file { cursor: pointer; font-weight: bold; color: #999; }
        #form-bottom-row { display: flex; gap: 10px; align-items: flex-end; }
        #file-input-label { padding: 8px; cursor: pointer; transition: opacity 0.2s; }
        #file-input-label svg { width: 24px; height: 24px; fill: #555; }
        #message-input { flex-grow: 1; padding: 10px; border: none; resize: none; font-size: 1em; height: 24px; max-height: 100px; overflow-y: auto; background: transparent; }
        #message-input:focus { outline: none; }
        #send-button { padding: 0 20px; border: none; background-color: var(--primary-color); color: white; border-radius: 20px; cursor: pointer; font-size: 1em; align-self: flex-end; margin: 5px; height: 40px; }
        #send-button:disabled { background-color: #a0a0a0; cursor: not-allowed; }
        #error-message { color: var(--error-color); padding: 10px 20px; text-align: center; font-weight: bold; display: none; }
        #toast-notification { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: #28a745; color: white; padding: 10px 20px; border-radius: 5px; z-index: 1000; opacity: 0; transition: opacity 0.5s; font-size: 0.9em; }
        #toast-notification.show { opacity: 1; }

        .api-key-guide { margin-top: 20px; font-size: 0.9em; color: #555; background-color: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid var(--border-color); }
        .api-key-guide h4 { margin-top: 0; margin-bottom: 10px; color: var(--text-color); font-size: 1.1em; }
        .api-key-guide ol { margin: 0; padding-left: 20px; line-height: 1.6; }
        .api-key-guide li { margin-bottom: 5px; }
        .api-key-guide a { color: var(--primary-color); font-weight: 500; text-decoration: none; }
        .api-key-guide a:hover { text-decoration: underline; }

        .history-management { margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border-color); }
        .history-management h4 { margin-top: 0; margin-bottom: 10px; color: var(--text-color); font-size: 1.1em; }
        .history-buttons { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .history-buttons button, .history-buttons .button-label { padding: 8px 15px; border: 1px solid var(--primary-color); background-color: white; color: var(--primary-color); border-radius: 5px; cursor: pointer; font-size: 0.9em; font-weight: 500; transition: background-color 0.2s, color 0.2s; text-align: center; display: inline-block; }
        .history-buttons button:hover, .history-buttons .button-label:hover { background-color: var(--primary-color); color: white; }
        .meta-container {
          display: flex;
          flex-direction: column-reverse;
          align-items: center;
          gap: 4px;
          flex-shrink: 0;
        }
    </style>
</head>
<body>

    <div class="app-container">
        <header>
            <h1 id="app-title">Ollama Chat</h1>
            <button id="settings-toggle">設定</button>
        </header>

        <form id="settings-form" class="hidden">
            <div class="settings-content">
                <div class="settings-grid">
                    <div class="form-group">
                        <label for="model-input">モデル</label>
                        <input type="text" id="model-input" name="model" placeholder="例: llama3, gemma">
                    </div>
                    <div class="form-group">
                        <label for="ollama-url-input">OllamaサーバーURL</label>
                        <input type="text" id="ollama-url-input" name="ollamaUrl" placeholder="例: http://localhost:11434">
                    </div>
                </div>
                <div class="apply-settings-wrapper">
                    <button type="submit" class="history-buttons button-label" style="background-color: var(--primary-color); color: white; border: none; padding: 10px 20px;">適用</button>
                </div>
                <div class="api-key-guide">
                    <h4>Ollamaのセットアップ</h4>
                    <ol>
                        <li><a href="https://ollama.com/" target="_blank" rel="noopener noreferrer">Ollama公式サイト</a>から、お使いのOS用のインストーラーをダウンロードして実行します。</li>
                        <li>ターミナル（またはコマンドプロンプト）を開き、<code>ollama run llama3</code> のようなコマンドでモデルをダウンロードして実行します。</li>
                        <li>Ollamaサーバーはデフォルトで <code>http://localhost:11434</code> で起動します。上記のURL入力欄にこのアドレスを入力してください。</li>
                        <li>使用したいモデル名（例: `llama3`, `gemma`）をモデル入力欄に入力し、「適用」ボタンを押します。</li>
                    </ol>
                    <p style="font-size: 0.85em; color: #666; margin-top: 10px; margin-bottom: 0;">※このページはOllamaサーバーと直接通信します。URLはブラウザのパラメータとしてのみ扱われます。</p>
                </div>
                <div class="history-management">
                    <h4>対話履歴の管理</h4>
                    <div class="history-buttons">
                        <button id="save-history-btn" type="button">履歴を保存</button>
                        <label for="restore-history-input" class="button-label">履歴を復元</label>
                        <input type="file" id="restore-history-input" accept=".json,application/json" style="display: none;">
                    </div>
                    <p style="font-size: 0.85em; color: #666; margin-top: 10px; margin-bottom: 0;">※現在の対話履歴をJSONファイルとして保存・復元できます。復元すると現在の履歴は上書きされます。</p>
                </div>
            </div>
        </form>

        <div id="error-message"></div>

        <div id="chat-container">
            <div id="chat-history"></div>
            <form id="chat-form">
                <div id="chat-form-container">
                    <div id="input-wrapper">
                        <div id="file-preview"></div>
                        <div id="form-bottom-row">
                           <label id="file-input-label" for="file-input">
                                <svg viewBox="0 0 24 24"><path fill="currentColor" d="M16.5,6V17.5A4,4 0 0,1 12.5,21.5A4,4 0 0,1 8.5,17.5V5A2.5,2.5 0 0,1 11,2.5A2.5,2.5 0 0,1 13.5,5V15.5A1,1 0 0,1 12.5,16.5A1,1 0 0,1 11.5,15.5V6H10V15.5A2.5,2.5 0 0,0 12.5,18A2.5,2.5 0 0,0 15,15.5V5A4,4 0 0,0 11,1A4,4 0 0,0 7,5V17.5A5.5,5.5 0 0,0 12.5,23A5.5,5.5 0 0,0 18,17.5V6H16.5Z" /></svg>
                           </label>
                           <input type="file" id="file-input" multiple style="display: none;">
                           <textarea id="message-input" placeholder="メッセージを入力、またはファイルをドロップ (Ctrl+Enterで送信)" rows="1"></textarea>
                           <button type="submit" id="send-button">送信</button>
                        </div>
                    </div>
                </div>
            </form>
        </div>
    </div>
    <div id="toast-notification">コピーしました！</div>

    <script type="module">
        // Data stores
        const codeBlocks = new Map();
        const attachedFileObjects = new Map();
        let codeBlockIdCounter = 0;
        let attachedFileIdCounter = 0;

        // DOM Elements
        const appContainer = document.querySelector('.app-container');
        const settingsForm = document.getElementById('settings-form');
        const settingsToggleBtn = document.getElementById('settings-toggle');
        const ollamaUrlInput = document.getElementById('ollama-url-input');
        const modelInput = document.getElementById('model-input');
        const chatContainer = document.getElementById('chat-container');
        const chatHistory = document.getElementById('chat-history');
        const chatForm = document.getElementById('chat-form');
        const inputWrapper = document.getElementById('input-wrapper');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const errorMessageDiv = document.getElementById('error-message');
        const fileInput = document.getElementById('file-input');
        const fileInputLabel = document.getElementById('file-input-label');
        const filePreview = document.getElementById('file-preview');
        const toastNotification = document.getElementById('toast-notification');
        const saveHistoryBtn = document.getElementById('save-history-btn');
        const restoreHistoryInput = document.getElementById('restore-history-input');
        const appTitle = document.getElementById('app-title');

        // State
        let conversationHistory = [];
        let messageTimestamps = [];
        let attachedFiles = [];
        let loadingIndicator;
        let debugMode = null; 
        let audioContext = null;
        
        function updateAppTitle() {
            const modelName = modelInput.value.trim();
            appTitle.textContent = modelName ? `Ollama Chat (${modelName})` : 'Ollama Chat';
        }

        function displayInitialWelcomeMessage() {
            const welcomeText = "ページの一番下にある枠にメッセージを入力し、送信するとAIが回答します。このページはローカルのOllamaサーバーと通信します。";
            const timestamp = new Date().toISOString();
            if (messageTimestamps.length === 0) {
                messageTimestamps.push(timestamp);
            }
            addMessageToDisplay('model', welcomeText, [], timestamp);
        }
        
        function renderFormattedContent(container, text, timestamp) {
            const placeholders = new Map();
            let placeholderId = 0;

            const codeBlockRegex = /```(\w*)\n([\s\S]*?)\n```/g;
            let processedText = text.replace(codeBlockRegex, (match, lang, code) => {
                const id = `%%CODE_BLOCK_PLACEHOLDER_${placeholderId++}%%`;
                const language = (lang || 'plaintext').toLowerCase();
                
                const isSvg = (language === 'svg' || language === 'xml') && code.trim().startsWith('<svg');
                let blockHtml;
                if (isSvg) {
                    blockHtml = `<div class="svg-container">${code}</div>`;
                } else {
                    const blockId = `code-block-${codeBlockIdCounter++}`;
                    const highlightedCode = hljs.getLanguage(language)
                        ? hljs.highlight(code, { language, ignoreIllegals: true }).value
                        : hljs.highlightAuto(code).value;
                    
                    codeBlocks.set(blockId, { code, language, timestamp });

                    blockHtml = `
                        <div class="code-block-wrapper" data-block-id="${blockId}">
                            <div class="code-header">
                                <span class="language-name">${language === 'plaintext' ? 'text' : language}</span>
                                <div class="code-actions">
                                    <button class="code-copy-btn">Copy</button>
                                    <button class="code-download-btn">Download</button>
                                </div>
                            </div>
                            <pre><code class="hljs language-${language}">${highlightedCode}</code></pre>
                        </div>
                    `;
                }
                
                placeholders.set(id, blockHtml);
                return id;
            });

            let html = '';
            if (typeof marked !== 'undefined') {
                html = marked.parse(processedText);
            } else {
                html = processedText.replace(/\n/g, '<br>');
            }
            
            html = html.replace(/<p>(%%CODE_BLOCK_PLACEHOLDER_\d+%%)<\/p>/g, (match, placeholder) => {
                return placeholders.get(placeholder) || '';
            });
            html = html.replace(/(%%CODE_BLOCK_PLACEHOLDER_\d+%%)/g, (match, placeholder) => {
                return placeholders.get(placeholder) || '';
            });
            
            container.innerHTML = html;
            
            if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                Promise.resolve().then(() => MathJax.typesetPromise([container]))
                    .catch((err) => console.error('MathJax typesetting error:', err))
                    .finally(() => chatHistory.scrollTop = chatHistory.scrollHeight);
            }
        }
        
        function addMessageToDisplay(sender, text, files = [], timestamp = null) {
            const messageDate = timestamp ? new Date(timestamp) : new Date();
            const messageRow = document.createElement('div');
            messageRow.classList.add('message-row', sender === 'user' ? 'user' : 'ai');
            
            const messageEl = document.createElement('div');
            messageEl.classList.add('message', sender === 'user' ? 'user-message' : 'ai-message');
            
            const contentEl = document.createElement('div');
            contentEl.classList.add('message-content');

            if (text) {
                renderFormattedContent(contentEl, text, timestamp);
            }

            if (sender === 'user' && files.length > 0) {
                const filesContainer = document.createElement('div');
                filesContainer.className = 'message-files-container';
                if (text) filesContainer.style.marginTop = '8px';
                
                files.forEach(file => {
                    const isFileObject = file instanceof File;
                    const isReconstructed = !!file.isReconstructed;
                    const mimeType = isFileObject ? file.type : (isReconstructed ? file.inlineData.mimeType : '');
                    const fileName = isFileObject ? file.name : (isReconstructed ? file.name : `添付ファイル`);
                    const isImage = mimeType && mimeType.startsWith('image/');
                    
                    let fileElement;
                    let fileId = null;

                    if (isReconstructed) {
                        const byteString = atob(file.inlineData.data);
                        const ab = new ArrayBuffer(byteString.length);
                        const ia = new Uint8Array(ab);
                        for (let i = 0; i < byteString.length; i++) {
                            ia[i] = byteString.charCodeAt(i);
                        }
                        const blob = new Blob([ab], { type: mimeType });
                        const reconstructedFile = new File([blob], fileName, { type: mimeType });
                        
                        fileId = `file-${attachedFileIdCounter++}`;
                        attachedFileObjects.set(fileId, reconstructedFile);

                    } else if (isFileObject) {
                        fileId = `file-${attachedFileIdCounter++}`;
                        attachedFileObjects.set(fileId, file);
                    }

                    if (isImage) {
                        const img = document.createElement('img');
                        if (fileId) {
                           const fileObj = attachedFileObjects.get(fileId);
                           img.src = URL.createObjectURL(fileObj);
                           img.onload = () => URL.revokeObjectURL(img.src);
                        } else {
                           img.src = `data:${mimeType};base64,${file.inlineData.data}`;
                        }
                        fileElement = img;
                    } else {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-display-item';
                        fileItem.innerHTML = `<svg viewBox="0 0 24 24"><path fill="currentColor" d="M16.5,6V17.5A4,4 0 0,1 12.5,21.5A4,4 0 0,1 8.5,17.5V5A2.5,2.5 0 0,1 11,2.5A2.5,2.5 0 0,1 13.5,5V15.5A1,1 0 0,1 12.5,16.5A1,1 0 0,1 11.5,15.5V6H10V15.5A2.5,2.5 0 0,0 12.5,18A2.5,2.5 0 0,0 15,15.5V5A4,4 0 0,0 11,1A4,4 0 0,0 7,5V17.5A5.5,5.5 0 0,0 12.5,23A5.5,5.5 0 0,0 18,17.5V6H16.5Z" /></svg><span>${fileName}</span>`;
                        fileElement = fileItem;
                    }
                    
                    if (fileId) {
                        fileElement.dataset.fileId = fileId;
                        fileElement.title = `クリックしてダウンロード: ${fileName}`;
                    }

                    filesContainer.appendChild(fileElement);
                });
                contentEl.appendChild(filesContainer);
            }
            
            messageEl.appendChild(contentEl);

            const timestampEl = document.createElement('div');
            timestampEl.classList.add('message-timestamp');
            timestampEl.textContent = messageDate.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });

            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-message-btn';
            copyBtn.title = 'メッセージをコピー';
            copyBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>`;
            copyBtn.setAttribute('data-copy-text', text);

            const metaContainer = document.createElement('div');
            metaContainer.className = 'meta-container';
            metaContainer.appendChild(timestampEl);
            metaContainer.appendChild(copyBtn);
            
            messageRow.appendChild(messageEl);
            messageRow.appendChild(metaContainer);

            chatHistory.appendChild(messageRow);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        function playNotificationSound() {
            if (!audioContext || audioContext.state !== 'running') {
                console.warn("AudioContext not available, skipping sound playback.");
                return;
            }
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            const now = audioContext.currentTime;
            const duration = 0.15;
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(880, now);
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.3, now + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration);
            oscillator.start(now);
            oscillator.stop(now + duration);
        }

        async function handleChatSubmit(e) {
            e.preventDefault();
            const userInput = messageInput.value.trim();
            if (!userInput && attachedFiles.length === 0) return;

            if (debugMode) {
                const filesToDisplay = [...attachedFiles];
                const timestamp = new Date().toISOString();
                if (debugMode === 'user') addMessageToDisplay('user', userInput, filesToDisplay, timestamp);
                else if (debugMode === 'ai') { addMessageToDisplay('model', userInput, [], timestamp); playNotificationSound(); }
                attachedFiles = []; renderFilePreview(); messageInput.value = ''; autoResizeTextarea();
                return;
            }

            inputWrapper.classList.add('submitting');
            sendButton.disabled = true; messageInput.disabled = true; fileInput.disabled = true;
            fileInputLabel.style.cssText = 'cursor: not-allowed; opacity: 0.5;';
            document.querySelectorAll('.remove-file').forEach(btn => btn.style.display = 'none');
            
            const filesToSend = [...attachedFiles];
            const userTimestamp = new Date().toISOString();
            const lastUserMessageRow = chatHistory.lastChild;

            addMessageToDisplay('user', userInput, filesToSend, userTimestamp);
            
            loadingIndicator.style.display = 'block';
            chatHistory.appendChild(loadingIndicator);
            chatHistory.scrollTop = chatHistory.scrollHeight;

            let userPartsForHistory = [];
            
            try {
                // 1. ユーザーの入力を履歴オブジェクトとして作成
                const fileMarkersText = filesToSend.map(file => `\n[添付ファイル: ${file.name}]`).join('');
                const combinedText = userInput + fileMarkersText;
                const generativeParts = await Promise.all(filesToSend.map(fileToGenerativePartForHistory));
                userPartsForHistory = [{ text: combinedText }, ...generativeParts];
                
                // 2. ユーザー入力を履歴に追加
                conversationHistory.push({ role: 'user', parts: userPartsForHistory });
                messageTimestamps.push(userTimestamp);
                
                // 3. Ollamaリクエスト用に履歴を変換
                const messagesForOllama = conversationHistory.map(entry => {
                    const role = entry.role === 'model' ? 'assistant' : 'user';
                    const textPart = entry.parts.find(p => p.text);
                    const content = textPart ? textPart.text.replace(/\n\[添付ファイル:.*?\]/g, '').trim() : '';
                    const imageParts = entry.parts.filter(p => p.inlineData);
                    const images = imageParts.map(p => p.inlineData.data);
                    
                    const message = { role, content };
                    if (images.length > 0) {
                        message.images = images;
                    }
                    return message;
                });

                // 4. Ollamaサーバーにリクエストを送信
                const ollamaUrl = ollamaUrlInput.value.trim();
                const modelName = modelInput.value.trim();
                const response = await fetch(`${ollamaUrl}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: modelName,
                        messages: messagesForOllama,
                        stream: false
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                const text = data.message.content;
                const aiTimestamp = new Date().toISOString();

                // 5. AIの応答を履歴とUIに追加
                conversationHistory.push({ role: 'model', parts: [{ text }] });
                messageTimestamps.push(aiTimestamp);
                addMessageToDisplay('model', text, [], aiTimestamp);

                playNotificationSound();
                clearError();
            } catch (error) {
                console.error('API Error:', error);
                // 失敗した場合、追加したユーザー入力とタイムスタンプを履歴から削除
                conversationHistory.pop(); 
                messageTimestamps.pop();
                
                const msg = error.message.includes("fetch") ? `Ollamaサーバーへの接続に失敗しました。URL (${ollamaUrlInput.value}) を確認し、Ollamaが起動しているか確認してください。` : `APIエラー: ${error.message}`;
                displayError(msg);
                
                // UIに表示したユーザーメッセージを削除
                if (chatHistory.lastChild && chatHistory.lastChild.classList.contains('message-row')) {
                    chatHistory.removeChild(chatHistory.lastChild);
                }
            } finally {
                inputWrapper.classList.remove('submitting');
                sendButton.disabled = false; messageInput.disabled = false; fileInput.disabled = false;
                fileInputLabel.style.cssText = 'cursor: pointer; opacity: 1;';
                if (loadingIndicator.parentNode) loadingIndicator.parentNode.removeChild(loadingIndicator);
                attachedFiles = []; renderFilePreview(); messageInput.value = ''; autoResizeTextarea();
            }
        }
        
        // 履歴保存機能のために、元のGeminiライブラリ互換のオブジェクトを作成する
        function fileToGenerativePartForHistory(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve({ inlineData: { data: reader.result.split(',')[1], mimeType: file.type } });
                reader.onerror = reject; reader.readAsDataURL(file);
            });
        }
        
        async function handleSaveHistory() {
            try {
                const currentHistory = conversationHistory;
                const historyTimestamps = messageTimestamps.slice(1);
                if (currentHistory.length === 0) { showToast("対話履歴がありません。"); return; }
                if (currentHistory.length !== historyTimestamps.length) { 
                    console.error('History and timestamp mismatch:', currentHistory.length, historyTimestamps.length);
                    displayError("履歴とタイムスタンプの数が一致しません。保存できません。"); 
                    return; 
                }
                const historyWithTimestamps = currentHistory.map((entry, index) => ({ ...entry, timestamp: historyTimestamps[index] }));
                const dataToSave = { version: "2.0", model: modelInput.value.trim(), history: historyWithTimestamps };
                const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                const now = new Date();
                a.download = `chat-history-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href);
                showToast("履歴を保存しました。");
            } catch (error) { displayError("履歴の保存に失敗しました。"); }
        }

        function handleRestoreHistory(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loadedData = JSON.parse(e.target.result);
                    let newHistory, newTimestamps;
                    if ((loadedData.version === "2.0" || loadedData.version === "1.0") && Array.isArray(loadedData.history)) {
                        newHistory = loadedData.history.map(entry => { const { timestamp, ...rest } = entry; return rest; });
                        newTimestamps = loadedData.history.map(entry => entry.timestamp);
                        if (loadedData.model) {
                            modelInput.value = loadedData.model;
                            updateAppTitle();
                        }
                    } else if (Array.isArray(loadedData)) { // 旧形式のサポート
                        newHistory = loadedData; newTimestamps = newHistory.map(() => new Date().toISOString());
                    } else { throw new Error("無効な履歴ファイル形式です。"); }
                    conversationHistory = newHistory;
                    messageTimestamps = [new Date().toISOString(), ...newTimestamps];
                    rebuildChatDisplay(conversationHistory, messageTimestamps);
                    
                    settingsForm.classList.add('hidden');
                    chatContainer.style.display = 'flex';
                    clearError();
                    showToast("履歴を復元しました。");
                } catch (error) { displayError(`履歴の復元に失敗しました: ${error.message}`); } finally { event.target.value = ''; }
            };
            reader.onerror = () => displayError("ファイルの読み込み中にエラーが発生しました。"); reader.readAsText(file);
        }
    
        function rebuildChatDisplay(history, timestamps) {
            chatHistory.innerHTML = '';
            attachedFileObjects.clear();
            attachedFileIdCounter = 0;
            const welcomeText = "ページの一番下にある枠にメッセージを入力し、送信するとAIが回答します。このページはローカルのOllamaサーバーと通信します。";
            addMessageToDisplay('model', welcomeText, [], timestamps[0]);
            
            history.forEach((message, index) => {
                const timestamp = timestamps[index + 1];
                if (message.role === 'user') {
                    const textPartContent = message.parts.find(p => p.text)?.text || '';
                    const inlineDataParts = message.parts.filter(p => p.inlineData);
                    const fileMarkerRegex = /\n\[添付ファイル: (.*?)\]/g;
                    
                    const reconstructedFiles = [];
                    const fileNames = (textPartContent.match(fileMarkerRegex) || []).map(marker => marker.replace(/\n\[添付ファイル: /, '').replace(/\]$/, ''));

                    inlineDataParts.forEach((part, i) => {
                        reconstructedFiles.push({
                            inlineData: part.inlineData,
                            name: fileNames[i] || `file_${i+1}.dat`,
                            isReconstructed: true
                        });
                    });
                    
                    const cleanedText = textPartContent.replace(fileMarkerRegex, '').trim();
                    addMessageToDisplay('user', cleanedText, reconstructedFiles, timestamp);
                } else {
                    const text = message.parts.map(p => p.text).join('\n\n');
                    addMessageToDisplay('model', text, [], timestamp);
                }
            });

            if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                Promise.resolve().then(() => MathJax.typesetPromise([chatHistory])).catch((err) => console.error('MathJax error:', err));
            }
        }

        function downloadFile(file) {
            const url = URL.createObjectURL(file);
            const a = document.createElement('a');
            a.href = url;
            a.download = file.name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function handleDownloadClick(code, language, messageDate) {
            const langMap = { 'javascript': 'js', 'python': 'py', 'html': 'html', 'css': 'css', 'java': 'java', 'csharp': 'cs', 'cpp': 'cpp', 'ruby': 'rb', 'go': 'go', 'shell': 'sh', 'bash': 'sh', 'json': 'json', 'sql': 'sql', 'typescript': 'ts', 'xml': 'xml', 'yaml': 'yaml', 'svg': 'svg' };
            const extension = langMap[language.toLowerCase()] || 'txt';
            const blob = new Blob([code], { type: 'text/plain' });
            
            const yyyy = messageDate.getFullYear();
            const mm = String(messageDate.getMonth() + 1).padStart(2, '0');
            const dd = String(messageDate.getDate()).padStart(2, '0');
            const h = String(messageDate.getHours()).padStart(2, '0');
            const min = String(messageDate.getMinutes()).padStart(2, '0');
            const fileName = `code-${yyyy}${mm}${dd}-${h}${min}.${extension}`;
            
            const file = new File([blob], fileName, { type: 'text/plain' });
            downloadFile(file);
        }
        
        function showToast(message) {
            toastNotification.textContent = message; toastNotification.classList.add('show');
            setTimeout(() => { toastNotification.classList.remove('show'); }, 3000);
        }

        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
        
        function handleFileDrop({ dataTransfer }) { if (inputWrapper.classList.contains('submitting')) return; addFiles(dataTransfer.files); }
        
        function handleFileSelect(e) { if (fileInput.disabled) return; addFiles(e.target.files); e.target.value = ''; }
        
        function addFiles(files) {
            for (const file of files) {
                if (!attachedFiles.some(f => f.name === file.name && f.size === file.size)) attachedFiles.push(file);
            }
            renderFilePreview();
        }

        function renderFilePreview() {
            filePreview.innerHTML = '';
            attachedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div'); fileItem.className = 'file-item';
                const fileName = document.createElement('span'); fileName.textContent = file.name;
                const removeBtn = document.createElement('span'); removeBtn.className = 'remove-file'; removeBtn.textContent = '×';
                removeBtn.onclick = () => { attachedFiles.splice(index, 1); renderFilePreview(); };
                fileItem.appendChild(fileName); fileItem.appendChild(removeBtn); filePreview.appendChild(fileItem);
            });
        }

        function displayError(message) { errorMessageDiv.innerHTML = message; errorMessageDiv.style.display = 'block'; }
        
        function clearError() { errorMessageDiv.textContent = ''; errorMessageDiv.style.display = 'none'; }
        
        function autoResizeTextarea() { messageInput.style.height = 'auto'; messageInput.style.height = `${messageInput.scrollHeight}px`; }
        
        function handleKeyDown(e) { if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); chatForm.requestSubmit(); } }

        function handlePaste(e) {
            if (inputWrapper.classList.contains('submitting')) return;
            const clipboardData = e.clipboardData || window.clipboardData;
            if (!clipboardData) return;
            const items = clipboardData.items;
            const filesToPaste = [];
            for (let i = 0; i < items.length; i++) {
                if (items[i].kind === 'file' && items[i].type.startsWith('image/')) {
                    const file = items[i].getAsFile();
                    if (file) {
                        const timestamp = new Date().getTime();
                        const extension = file.type.split('/')[1] || 'png';
                        const newName = `pasted-image-${timestamp}.${extension}`;
                        const newFile = new File([file], newName, { type: file.type, lastModified: file.lastModified, });
                        filesToPaste.push(newFile);
                    }
                }
            }
            if (filesToPaste.length > 0) {
                e.preventDefault();
                addFiles(filesToPaste);
            }
        }

        function initializeApp() {
            if (typeof marked !== 'undefined') {
                marked.setOptions({ gfm: true, breaks: true, mangle: false, headerIds: false });
            }

            const initAudio = () => {
                if (audioContext) return;
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                } catch (e) { console.error("Web Audio API is not supported in this browser.", e); }
            };
            document.body.addEventListener('click', initAudio, { once: true });
            document.body.addEventListener('keydown', initAudio, { once: true });

            settingsForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const ollamaUrl = ollamaUrlInput.value.trim();
                const model = modelInput.value.trim();
                if (!ollamaUrl || !model) {
                    displayError("OllamaサーバーURLとモデル名を両方入力してください。");
                    return;
                }
                const newUrlParams = new URLSearchParams();
                newUrlParams.set('model', model);
                newUrlParams.set('ollamaUrl', ollamaUrl);
                window.location.search = newUrlParams.toString();
            });

            settingsToggleBtn.addEventListener('click', () => settingsForm.classList.toggle('hidden'));
            
            chatForm.addEventListener('submit', handleChatSubmit);
            messageInput.addEventListener('input', autoResizeTextarea);
            messageInput.addEventListener('keydown', handleKeyDown);
            fileInput.addEventListener('change', handleFileSelect);

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eName => inputWrapper.addEventListener(eName, preventDefaults, false));
            ['dragenter', 'dragover'].forEach(eName => inputWrapper.addEventListener(eName, () => inputWrapper.classList.add('drag-over'), false));
            ['dragleave', 'drop'].forEach(eName => inputWrapper.addEventListener(eName, () => inputWrapper.classList.remove('drag-over'), false));
            inputWrapper.addEventListener('drop', handleFileDrop, false);
            inputWrapper.addEventListener('paste', handlePaste, false);

            saveHistoryBtn.addEventListener('click', handleSaveHistory);
            restoreHistoryInput.addEventListener('change', handleRestoreHistory);
            
            chatHistory.addEventListener('click', (e) => {
                const codeButton = e.target.closest('.code-copy-btn, .code-download-btn');
                if (codeButton) {
                    const wrapper = codeButton.closest('.code-block-wrapper');
                    const blockId = wrapper?.dataset.blockId;
                    const block = blockId ? codeBlocks.get(blockId) : null;
                    if (!block) return;
                    if (codeButton.classList.contains('code-copy-btn')) {
                        navigator.clipboard.writeText(block.code).then(() => showToast("コードをコピーしました！"));
                    } else {
                        const messageDate = block.timestamp ? new Date(block.timestamp) : new Date();
                        handleDownloadClick(block.code, block.language, messageDate);
                    }
                    return;
                }
                
                const msgCopyButton = e.target.closest('.copy-message-btn');
                if (msgCopyButton) {
                    const textToCopy = msgCopyButton.dataset.copyText;
                    if (textToCopy !== null && textToCopy !== undefined) {
                        navigator.clipboard.writeText(textToCopy).then(() => {
                            showToast("メッセージをコピーしました！");
                        }).catch(err => {
                            console.error('Failed to copy text:', err);
                            showToast("コピーに失敗しました。");
                        });
                    }
                    return;
                }
                
                const fileElement = e.target.closest('[data-file-id]');
                if(fileElement) {
                    const fileId = fileElement.dataset.fileId;
                    const fileToDownload = attachedFileObjects.get(fileId);
                    if (fileToDownload) {
                        downloadFile(fileToDownload);
                    }
                }
            });

            loadingIndicator = document.createElement('div');
            loadingIndicator.id = 'loading-indicator';
            loadingIndicator.innerHTML = `
                <div class="message-row ai">
                    <div class="typing-indicator-bubble">
                        <div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>
                    </div>
                    <div class="message-timestamp">&nbsp;</div>
                </div>
            `;

            const urlParams = new URLSearchParams(window.location.search);
            const ollamaUrlFromUrl = urlParams.get('ollamaUrl');
            const modelFromUrl = urlParams.get('model');
            debugMode = urlParams.get('debugMode');
            
            ollamaUrlInput.value = ollamaUrlFromUrl || 'http://localhost:11434';
            modelInput.value = modelFromUrl || 'llama3';
            updateAppTitle();

            if (debugMode === 'user' || debugMode === 'ai') {
                settingsForm.classList.add('hidden');
                chatContainer.style.display = 'flex';
                clearError();
                displayInitialWelcomeMessage();
                
                const debugNotice = document.createElement('div');
                debugNotice.style.cssText = 'background-color: #fff3cd; color: #856404; padding: 10px 20px; text-align: center; font-weight: bold; border-bottom: 1px solid var(--border-color); font-size: 0.9em;';
                debugNotice.textContent = `デバッグモード (${debugMode}) で動作中`;
                appContainer.insertBefore(debugNotice, settingsForm.nextSibling);

                const historyManagement = document.querySelector('.history-management');
                if (historyManagement) {
                    historyManagement.style.opacity = '0.5';
                    historyManagement.style.pointerEvents = 'none';
                    const historyButtons = historyManagement.querySelectorAll('button, label');
                    historyButtons.forEach(btn => btn.tabIndex = -1);
                }

            } else if (ollamaUrlFromUrl) {
                settingsForm.classList.add('hidden');
                chatContainer.style.display = 'flex';
                clearError();
                displayInitialWelcomeMessage();
            } else {
                settingsForm.classList.remove('hidden');
                displayError("Ollamaサーバーが設定されていません。設定画面でURLとモデル名を入力し、「適用」を押してください。");
                chatContainer.style.display = 'none';
            }
        }

        // Initialize the application
        initializeApp();
    </script>
</body>
</html>